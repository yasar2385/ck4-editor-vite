/**
 * src/core/editorSocketBridge.jsx
 * Unified CKEditor event + socket handler (with callback to React)
 */

import { useRef, useCallback } from "react";

import useSocket from "../socket";
import { OTUtils, TextOp } from "../plugins/collab-ot";


// Debounce helper
function useDebounce(callback, delay = 400) {
  const timer = useRef(null);

  const debouncedFn = useCallback(
    (...args) => {
      if (timer.current) clearTimeout(timer.current);
      timer.current = setTimeout(() => {
        callback(...args);
      }, delay);
    },
    [callback, delay]
  );

  return debouncedFn;
}

export default function useEditorSocketBridge(editorInstance, userId = "Guest", onEditorEvent) {
  const editorRef = useRef(null);

  const { sendMessage } = useSocket("/collaboration", (msg) => {
    if (msg.type === "op") {
      try {
        const op = TextOp.fromJSON(msg.op);
        console.log("ðŸ“© Remote operation:", op);
        applyRemoteOp(op);
      } catch (err) {
        console.error("âš ï¸ Invalid remote op:", err);
      }
    }
  });


  // editorRef.current = editorInstance;


  let shadowText = "";
  let lastParagraph = null;

  const emitEvent = (type, details = {}) => {
    if (typeof onEditorEvent === "function") {
      onEditorEvent({
        type,
        details,
        time: new Date().toLocaleTimeString(),
      });
    }
  };

  // âœ… Apply remote operations
  const applyRemoteOp = (op) => {
    const editor = editorRef.current;
    if (!editor) return;
    const before = editor.getData();
    const updated = OTUtils.applyTextOp(before, op);
    if (before !== updated) {
      // editor.setData(updated);
      // shadowText = updated;
      emitEvent("remoteOpApplied", { length: updated.length });
    }
  };

  // âœ… Debounced key event
  const handleKey = useDebounce(() => {
    const editor = editorRef.current;
    if (!editor) return;
    const current = editor.getData();
    if (current === shadowText) return;
    const op = OTUtils.diffToOp(shadowText, current);
    if (!op) return;
    shadowText = current;
    sendMessage({
      type: "submit",
      user: userId,
      op: op.toJSON(),
      time: new Date().toISOString(),
    });
    emitEvent("key", { length: current.length });
  }, 600);

  // âœ… Click handler (ignore same paragraph)
  const handleClick = (evt) => {
    const target = evt.data?.getTarget?.();
    const para = target?.getAscendant("p", true);
    const paraId = para?.getId?.() || para?.getUniqueId?.() || "unknown";
    if (paraId === lastParagraph) return; // ignore same
    lastParagraph = paraId;
    emitEvent("click", { paragraphId: paraId });
  };

  // âœ… Bind once
  let boundOnce = false;
  const bindEditorEvents = useCallback((instance) => {
    if (!instance || boundOnce) return;
    editorRef.current = instance;
    boundOnce = true; // âœ… prevents rebind loop

    // shadowText = instance.getData();
    instance.on("change", handleKey);
    instance.on("key", handleKey);
    instance.on("paste", handleKey);
    instance.on("click", handleClick);

    emitEvent("bind", { message: "Editor events bound successfully" });
  }, []); // âœ… stable reference

  return { bindEditorEvents };
}
